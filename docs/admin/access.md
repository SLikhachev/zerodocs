# Контроль доступа

В актуальной версии приложения [SPA](./spa.md) всегда отправляют [JWT](jwt_auth.md) при
запросах к [pg_rest](./pg_rest.md) и [task_rest](./task_rest.md) сервисам.

_JWT_ заявление содержит поля:

    {
        "role":"webuser",
        "user":"user",
        "exp":exipred
    }

В поле __role__ находится имя роли БД Postgresql которое будет установлено как

    SET LOCAL ROLE webuser;

сразу после соединения с БД (то есть, роль локальной сессии, со всеми правами и
ограничениями для этой роли).

Само соединение производится по `DSN` указанному в конфигурационном файле
[pg_rest](pg_rest.md) сервера и в параметрах конфигурации приложения
[task_rest](./task_rest.md).

> Например: [postgres://dbuser:usersecret@localhost:5432/userbase?ssl=disable](#контроль-доступа)

---

## Доступ к таблицам и записям БД

Допустим, далее по тексту, что владелец БД - роль __dbowner__.

Для некоторых таблиц установлены правила `RLS`, таким образом, что каждая такая таблица
имеет дополнительное поле (колонку) __cuser__, которе устанавливает права на эту запись.

При добавлении записи в таблицу, это поле должно быть указано обязательно, если для такой
таблицы установлены правила `RLS` (по дефолту в данное поле записывается значение
переменной __current_user__ СУБД).

Если для текущего пользователя сессии действуют правила `RLS`, изменить или удалить
записи с `RLS` может только владелец записи (или суперпользователь БД).

При чтении из таблицы, при определенных условиях, будут выбраны только те записи,
которые имеют, одинаковое значение поля __cuser__.

---

## Сервис pg_rest

Для  __pg_rest__ установлены три типа ролей:

- anonymous
- authenticator (auth)
- user

Роль __auth__ не должна наследоваться __(NOINHERIT)__ другими ролями, и должна иметь
ограниченный доступ к базе. Эта роль предназначена, для соединения с базой, с последующей установкой текущей роли сессии.

Администратор БД должен предоставить роли __auth__ право наследовать роли __anonymous__
и __user__

    GRANT user TO authenticator;
    GRANT anonymous TO authenticator;

В этом случае после соединения с БД можно будет установить текущую роль сессии:

    SET LOCAL ROLE user;

Конфигурация сервера может содержать или не содержать параметр __jwt-secret__.

Возможные варианты:

<h6>jwt-secret отсутствует</h6>

- клиент __НЕ__ передает северу `HTTP` заголовок `Authorization Bearer JWT`

> В этом случае *pg_rest* переключится на локальную анонимную роль, которая должна быть
> точно указана в конфигурационном файле сервера.
>
> Если в качестве анонимной роли указана роль __dbowner__, или __postgres__, в этом случае
> правила `RLS` будут проигнорированы, а значение переменной **current_user** в данной сессии
> будет соответственно __dbowner__, или __postgres__.

- клиент __ПЕРЕДАЕТ__ северу `HTTP` заголовок `Authorization Bearer JWT`

> В этом случае запрос заканчивается с ошибкой.

---

<h6>jwt-secret установлен</h6>

- клиент __НЕ__ передает северу `HTTP` заголовок `Authorization Bearer JWT`

> В этом случае запрос заканчивается с ошибкой.

- клиент __ПЕРЕДАЕТ__ северу `HTTP` заголовок `Authorization Bearer JWT`

> и заявлено поле __role__, в этом случае *pg_rest* переключится на локальную роль
> заявленную в этом поле, если такого поля в заявлении нет, *pg_rest* переключится
> на локальную анонимную роль, указанную в конфигурационном файле сервера.
>
> Разрешения для анонимной роли, должны быть установлены администратором БД, таким
> образом, чтобы предотвратить доступ этой роли к определенному содержимому БД.

---

### pg_rest сервер для БД развернутой в LAN/VPN МО

В случае частной БД доступной только для конкретной организации, рекомендуются следующие
настройки БД и *pg_rest* сервера.

Для БД в качестве суперюзера создаем пользователей __dbauth, dbowner, dbuser__ с правами

    CREATE ROLE dbauth NOINHERIT LOGIN PASSWORD 'mysecret';
    CREATE ROLE dbowner NOLOGIN CREATEDB;
    CREATE ROLE dbuser NOLOGIN;
    GRANT dbowner TO dbauth;
    GRANT dbuser TO dbauth;

В данной конфигурации роль анонимного пользователя выполняет __dbuser__

Коннектимся к БД как __dbauth__, устанавливаем локального пользователя __dbowner__,
создаем БД, выполняем инициализацию базы и даем анонимному пользователю
право на чтение всех таблиц:

    SET LOCAL ROLE dbowner;
    CREATE DATABASE ourbase;
    -- restore dump of the empty db or if have template use it ---
    GRANT ALL ON ALL TABLES TO dbuser;
    -- + право чтения последовательностей и предствалений

Таким образом:

- роль для коннекта к СУБД __dbauth__;
- владелец базы со всеми правами __dbowner__;
- анонимный пользователь со всеми правами на БД __dbuser__.

В данной конфигурации мы не используем `RLS`. Владелец имеет все права, и для корректной
работы **pg_rest** в таком режиме конфигурация сервер PostgRest может выглядеть
следующим образом:

    db-uri="postgres://dbauth:mysecret@my_host:my_port/ourbase"
    server-port=9090
    db-schema="public"
    db-anon-role="dbuser"
    jwt-secret="super_sectret_string"

При этом каждый запрос к **pg_rest** должен содержать `HTTP` заголовок:

    Authorization Bearer JWT

где JWT собственно подписанный токен содержащий заявление:

    {
        "role":"dbuser",
        "user":"cuser",
        "exp":exipred
    }

---

### Контроль поля _cuser_

При такой организации доступа к непубличной базе каждый запрос на добавление/изменение
записей может (и возможно должен) содержать явное значение для поля __cuser__, для тех
таблиц, в которых есть такая колонка. При отсутствии значения, как выше указано, в такое
поле будет установлено значение переменной **current_user** (то есть фактически имя роли
для локальной сессии)

### Дефолтный способ конфигурации для pg_rest

Поскольку в актуальной версии приложения _SPA_ всегда отправляют _JWT_, данный
раздел приведен исключительно в справочных целях.

В самом простом случае, чтобы не усложнять конфигурацию сервера, можно не указывать
параметр

    jwt-secret="super_sectret_string"

в конфигурации севера. В этом случае, после соединения с сервером будет установлена локальная
роль __db-anon-role__ конфигурации. Если определить этот параметр как

    db-anon-role="dbowner"

сразу после соединения с сервером, локальной ролью будет роль __dbowner__ со всеми правами
в отношении БД. Никакие дальнейшие настройки не требуются.

В этом случае все замечания в отношении контроля поля __cuser__ остаются такими же как
указано выше (то есть, вы можете либо явно задавать значение этого поля, либо оставить
его дефолтными, в данном примере значение будет __dbowner__)

### pg_rest сервер для БД развернутой в публичном облаке

В публичном облаке мы не размещаем конфиденциальной информации. Вся информация в БД
является тестовой, и предназначено только для демонстрации работы приложения.

Поскольку в этом случае, доступ к БД имеет множество пользователей приложения, никак между
собой не связанных, каждый запрос к серверу *pg_rest* будет содержать _JWT_ с обязательными
заявлениями __role__ и __user__.

    {
        "role":"webuser",
        "user": "( web site logged in user )"
    }

Публичная анонимная роль: __webanon__, роль локальной сессии: __webuser__.
Роли __auth__ и __dbowner__ - вспомогательные.
Роли __webanon__ не предоставлено никаких прав, поэтому, каждый запрос должен иметь
подписанный токен.

Роли __webuser__ предоставлены права:

    GRANT SELECT ON ALL TABLES IN SCHEMA public TO webuser;
    GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO webuser;
    GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO webuser;
    GRANT ALL ON TABLE some_cuser_controlled_tables TO webuser;

Для некоторых таблиц (имеющих колонку __cuser__) мы обязательно устанавливаем правила `RLS`.

    ALTER TABLE public.some_table ENABLE ROW LEVEL SECURITY;
    CREATE POLICY some_table_policy ON public.some_table
        USING (current_setting('request.jwt.claim.user', false) = cuser);

Эти установки действительны для `Postgresql version < 14`.

Указанная переменна __'request.jwt.claim.user'__ автоматически устанавливается сервером
**pg_rest**.

Для публичного облака конфигурация сервера должна быть такой:

    # postgrest.conf

    # The standard connection URI format, documented at
    # https://www.postgresql.org/docs/current/static/libpq-connect.html#AEN45347
    db-uri = "postgres://dbatuh:my_secret@my_host:5432/demobase"
    server-port = a_port

    #-----------------------------------------------------------
    # The name of which database schema to expose to REST clients
    db-schema = "public"

    #-----------------------------------------------------------
    # The database role to use when no client authentication is provided.
    # Can (and probably should) differ from user in db-uri
    db-anon-role = "webanon"
    log-level="info"
    jwt-secret="my_hard_top_secret"

    # this server will be used with Auth bearer and RLS

## Сервис task_rest

Источником конфигурация приложения *task_rest* служит, в том числе, и наличие
определенных переменных среды исполнения приложения. В рамках данной темы имеют
значение 2 переменные:

    DB_AUTH="yes/no"
    JWT_TOKEN_SECRET=""

Для того, чтобы применялись описанные выше правила контроля доступа, необходимо, чтобы
выполнялись условия:

1. переменная `DB_AUTH` была установлена и имела значение `yes`;
2. переменная `JWT_TOKEN_SECRET`была установлена и не была пустой строкой.

### task_rest переменные среды не установлены

Если одно из условий не выполнено, приложение __игнорирует__ правила контроля доступа,
при этом:

- роль локальной сессии при коннекте к БД будет роль указанная в `DSN`;
- значением переменной **current_user** в данной сессии будет роль указанная в `DSN`.

### task_rest переменные установлены

При выполнении обоих условий, будет выполнен анализ заголовка `Authorization` запроса.
Если в процессе анализа заголовка `Authorization`, или доступа к таблицам и записям БД
возникает ошибка, выполнение задачи прекращается, и возвращается сообщение об ошибке,
если ошибок нет, все описанные выше правила доступа к БД будут применятся при выполнении
задач приложения.
